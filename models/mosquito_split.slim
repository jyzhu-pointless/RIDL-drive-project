// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.
// A framework for simulating many different gene drives
// with varying parameters.

// Mosquito model with split RIDL-drive (by Jinyu Zhu)
// 12.12: fixed some crucial bugs

initialize() {
	defineCfgParam("SPEED_RUN", F);
	
	// Modify the number of offspring to calc the genetic load.
	defineCfgParam("GL_RUN", F);
	defineConstant("BONUS_POP_FACTOR", 1.0);
	defineConstant("PREV_BONUS_POP_FACTOR", 1.0);
	defineConstant("ACTUAL_LARVAE", 0);
	
	// NEW STUFF:
	defineCfgParam("REMATE_CHANCE", 0.05);
	defineCfgParam("OLD_LARVA_COMPETITION_FACTOR", 5.0);
	defineCfgParam("NUM_ADULT_FEMALES", 500);
	defineConstant("AVG_NUM_EGG_BATCHES", (1522 / 729) * 0.6);
	defineCfgParam("BETAMAX", 25);
	defineCfgParam("FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK", 0.5);
	
	defineConstant("INITIAL_FEMALE_AGE_DISTRIBUTION", c(FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK * BETAMAX, 0.285714286, 0.285714286, 0.238095238, 0.19047619, 0.142857143, 0.095238095, 0.047619048));
	defineConstant("INITIAL_MALE_AGE_DISTRIBUTION", c(FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK * BETAMAX, 0.285714286, 0.285714286, 0.19047619, 0.095238095));
	
	// Fitness parameters:
	// chromosome 1: Cas9 (unused)
	defineCfgParam("DD_FITNESS_VALUE_CAS", 1.0);
	defineCfgParam("DX_FITNESS_VALUE_CAS",sqrt(DD_FITNESS_VALUE_CAS));
	// chromosome 2: Cargo gene and resistance alleles
	defineCfgParam("DD_FITNESS_VALUE", 1.0);
	defineCfgParam("DX_FITNESS_VALUE",sqrt(DD_FITNESS_VALUE));
	
	
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_F", 1.0);
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_M", 1.0);
	defineCfgParam("GENE_DISRUPTION_FITNESS_MULTIPLIER", 0.0);
	defineCfgParam("R2_FITNESS_VALUE", 1.0);
	
	// Drive type:
	defineCfgParam("HOMING_DRIVE", T);
	defineCfgParam("HAPLOLETHAL_DRIVE", F);
	defineCfgParam("RECESSIVE_LETHAL_DRIVE", F);
	defineCfgParam("GENE_DISRUPTION_DRIVE", F);
	defineCfgParam("RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE", F);
	defineCfgParam("HAPLOLETHAL_SUPPRESSION_DRIVE", F);
	defineCfgParam("DOMINANT_FEMALE_STERILE", F);
	defineCfgParam("DOMINANT_STERILE_R2", F);
	
	defineCfgParam("FEMALE_RIDL", T);
	defineCfgParam("BOTH_SEX_RIDL", F);
	defineCfgParam("MALE_SIT", F);
	
	//defineCfgParam("VIABILITY_MODEL", T);
	defineCfgParam("X_SHRED_RATE", 0.0);
	
	// HDR phase parameters:
	defineCfgParam("DRIVE_CONVERSION_RATE", 0.5);
	defineCfgParam("HOMING_PHASE_CUT_RATE_F", DRIVE_CONVERSION_RATE);
	defineCfgParam("HOMING_PHASE_CUT_RATE_M", DRIVE_CONVERSION_RATE);
	defineCfgParam("HOMING_EDGE_EFFECT", 0.055);
	defineCfgParam("BASELINE_HOMING_SUCCESS_RATE", 1.0);
	defineCfgParam("PARTIAL_HDR_RATE", 0.0);
	defineCfgParam("PER_OFFSET_PARTIAL_HDR_RATE_INCREASE", 0.0);
	defineCfgParam("PARTIAL_HDR_R1_RATE", 0.0);
	
	// Resistance phase parameters:
	defineCfgParam("NUM_CUT_PHASES", 1);
	defineCfgParam('TOTAL_GERMLINE_RESISTANCE_RATE', 0.0);
	defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_F", 0.0);
	defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_M", 0.0);
	defineCfgParam("LATE_GERMLINE_RESISTANCE_CUT_RATE_F", TOTAL_GERMLINE_RESISTANCE_RATE / (1 - DRIVE_CONVERSION_RATE));
	defineCfgParam("LATE_GERMLINE_RESISTANCE_CUT_RATE_M", TOTAL_GERMLINE_RESISTANCE_RATE / (1 - DRIVE_CONVERSION_RATE));
	defineCfgParam("EMBRYO_RESISTANCE_CUT_RATE_F", 0.0);
	defineCfgParam("EMBRYO_RESISTANCE_CUT_RATE_M", 0.0);
	defineCfgParam("HET_MOTHER_CAS_INHERITANCE", 1.83);
	defineCfgParam("R1_OCCURRENCE_RATE", 0.0);
	
	// General drive parameters:
	defineCfgParam("NUM_GRNAS", 1);
	defineCfgParam("GRNA_ACTIVITY_VARIATION", 0.0);
	defineCfgParam("GLOBAL_SATURATION_FACTOR", 1.5); // Has no effect when set to 2.
	defineCfgParam("X_LINKED", F);
	defineCfgParam("Y_LINKED", F);
	defineCfgParam("MALE_ONLY_PROMOTER", F);
	defineCfgParam("GRNA_SATURATION_SIMULATED", F);
	
	// Ecology and drop parameters:
	defineCfgParam("TOTAL_FEMALES", NUM_ADULT_FEMALES + (FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK * BETAMAX+ 0.285714286)*NUM_ADULT_FEMALES);
	defineConstant("CALC_INITIAL_FEMALE_AGE", FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK * BETAMAX+ 0.285714286 + 0.285714286 + 0.238095238 + 0.19047619 + 0.142857143+ 0.095238095+ 0.047619048);
	defineConstant("CALC_INITIAL_MALE_AGE", FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK * BETAMAX + 0.285714286 + 0.285714286+ 0.19047619+ 0.095238095);
	defineCfgParam("CAPACITY", TOTAL_FEMALES + TOTAL_FEMALES*CALC_INITIAL_MALE_AGE/CALC_INITIAL_FEMALE_AGE);
	
	defineCfgParam("DROP_RATIO", 2.0);
	defineCfgParam("DROP_SIZE", (0.285714286+ 0.19047619+ 0.095238095)*NUM_ADULT_FEMALES*DROP_RATIO/3.166666667);
	defineCfgParam("MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE", 10);
	defineCfgParam("LOW_DENSITY_GROWTH_RATE", 6.0);
	defineCfgParam("DENSITY_GROWTH_CURVE","linear"); //1 means concave, 2 means linear, 3 means convex
	defineCfgParam("RATE_FEMALES_SURVIVE", 0.0);  // For partially overlapping generations.
	defineCfgParam("MALE_ONLY_DROP", T);
	defineCfgParam("FEMALE_ONLY_DROP", F);
	defineCfgParam("HETEROZYGOUS_DROP", F);
	
	    // Calculate activity step between each gRNA.
    if (NUM_GRNAS == 1)
        defineConstant("GRNA_ACTIVITY_STEP", 0);
    else
        defineConstant("GRNA_ACTIVITY_STEP", (2 * GRNA_ACTIVITY_VARIATION)  / (NUM_GRNAS));

    // For mortality rate as a function of age, for runs with overlaping generations.
    // Some females may be allowed to survive two generations:
    defineCfgParam("MALE_MORTALITY", c(1.0));
    defineCfgParam("FEMALE_MORTALITY", c((1.0 - RATE_FEMALES_SURVIVE), 1.0));

    // This simulation will use a non-Wright-Fisher model.
    initializeSLiMModelType("nonWF");

//

// variations: Wild type, drive, r1 resistance, r2 resistance.



//2 wt locus on 2 chromosomes
	 wt1 = initializeMutationType("m7", 0.5, "f", 0.0);
    wt2 = initializeMutationType("m1", 0.5, "f", 0.0);
//2 drive elements
    dr1 = initializeMutationType("m8", 0.5, "f", 0.0);//cas9
    dr2 = initializeMutationType("m2", 0.5, "f", 0.0);//grna1
 
    
//resistance alleles
    r1  = initializeMutationType("m3", 0.5, "f", 0.0);//r1 occurs on chromosome 2
    r2  = initializeMutationType("m4", 0.5, "f", 0.0);//r2 occurs on chromosome 2

//cut and gap 
    cut = initializeMutationType("m5", 0.5, "f", 0.0);
    gap = initializeMutationType("m6", 0.5, "f", 0.0);//never occur in 1 gRNA drive system
	 
//drive_variations = c(wt, dr, r1, r2, cut, gap);
	 	 //pesticide_variations = c(ps,pr);
    	 // Variations are all part of g1 genome element.
    drive_variations = c(wt1, dr1,wt2, dr2, r1, r2, cut, gap);      //nothing will target g1(cas9 here?)

    initializeGenomicElementType("g1", drive_variations, c(1, 1, 1, 1, 1, 1, 1, 1));
	 //initializeGenomicElementType("g2", drive_variations2, c(1, 1, 1, 1, 1, 1));


// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.	    
    initializeGenomicElement(g1, 0, 2*(NUM_GRNAS)+2);//(0,1)
    
	 //initializeGenomicElement(g2, NUM_GRNAS+3, );//(1+1,1+1+1)
    
// These mutations overwrite one another.
    drive_variations.mutationStackPolicy = "l";
    drive_variations.mutationStackGroup = 1;
   // drive_variations2.mutationStackPolicy = "l";
   // drive_variations2.mutationStackGroup = 1;

//for 2 elements daisy chain design, seperate the chromosomes into 2, set the recombination to 0.5 to represent 2independent chromosomes
	rates = c(0.0, 0.5,0.0);
	//01  “2” 34  “5”
   ends =  c(NUM_GRNAS+1,NUM_GRNAS+2 ,2*NUM_GRNAS+2+1);
   initializeRecombinationRate(rates, ends);
	initializeMutationRate(0.0);	
	// Simulate sexual reproduction: A for autosome.
	initializeSex("A");
}

//// HELPER FUNC FOR CONSTANTS THAT MAY ASLO BE CONFIGURED VIA COMMAND LINE.
function (void)defineCfgParam(string$ name, lifs value) {
	if (!exists(name))
		defineConstant(name, value);
}

//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}

//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate, [l maleParent=F]) {
	if (!maleParent) {
		// Determine presence of drive in this parent.
		parent_drive_count_g = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
		parent_drive_count_c = sum(parent.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
		
		// If parent doesn't have drive allele (both gRNA and Cas9 are required), 
		// nothing happens in germline.
		if ((!parent_drive_count_g) | (!parent_drive_count_c))
			return;
	}
	if (maleParent) {
		maternal_c = asInteger(parent.tag / 1000);
		maternal = asInteger((parent.tag - 1000 * maternal_c) / 100);
		paternal_c = asInteger((parent.tag - maternal_c  * 1000 - maternal * 100) / 10);
		paternal = parent.tag - maternal_c  * 1000 - maternal * 100 - paternal_c * 10;
		if ((maternal != 2 | maternal_c != 8) & (paternal != 2 | paternal_c != 8))
			return;
	}
	
	// cat(child_chromosome.countOfMutationsOfType(m1) + ",");
	// cat(child_chromosome.countOfMutationsOfType(m2) + "\n");
	
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	
	// cat("##" + 111222 + "##");	
	
	// This model allows for varying rates of cutting at each locus.
	// Therefore, the cut rate is a vector of rates.
	cas_factor = GLOBAL_SATURATION_FACTOR * grna_factor / (GLOBAL_SATURATION_FACTOR - 1 + grna_factor);
	local_cas_factor = cas_factor * (1 + GRNA_ACTIVITY_VARIATION);
	local_cut_rate = 1 - (1 - resistance_rate)^(local_cas_factor / (NUM_CUT_PHASES * grna_factor));
	// The above cut rate is the first rate in the vector.
	// cut_rates = local_cut_rate;
	// Now fill in the rest of the vector.
	for (i in seqLen(NUM_GRNAS - 1)) {
		local_cas_factor = cas_factor * (1 + GRNA_ACTIVITY_VARIATION - (i + 1) * GRNA_ACTIVITY_STEP);
		local_cut_rate = 1 - (1 - resistance_rate)^(local_cas_factor / (NUM_CUT_PHASES * grna_factor));
		// Concatenate the previous vector with the next cut rate calculated:
		// cut_rates = c(cut_rates, local_cut_rate);
	}
	// cat("##" + cut_rates + "##");
	// Determine if cas9 cuts the chromosome in the germline.
	casCut(child_chromosome, local_cut_rate);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother, f$ resistance_rate) {
	// Determine presence of drive in this mother.
	mother_drive_count_g = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	mother_drive_count_c = sum(mother.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
	
	// If mother doesn't have drive allele (both gRNA and Cas9 are required), 
	// nothing happens in embryo.
	if ((!mother_drive_count_g) | (!mother_drive_count_c))
		return;
	
	// Determine the per phase cut rate.
	if (HOMING_DRIVE & sum(mother.genomes.countOfMutationsOfType(m1) == NUM_GRNAS) == 1)
		// Special case for homing drive individual that is dr/wt based on experimental data.
		mother_drive_count_c = HET_MOTHER_CAS_INHERITANCE;
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	
	// This model allows for varying rates of cutting at each locus.
	// Therefore, the cut rate is a vector of rates.
	cas_factor = GLOBAL_SATURATION_FACTOR * grna_factor / (GLOBAL_SATURATION_FACTOR - 1 + grna_factor);
	local_cas_factor = cas_factor * (1 + GRNA_ACTIVITY_VARIATION);
	local_cut_rate = 1 - (1 - resistance_rate)^(mother_drive_count_c * local_cas_factor / (NUM_CUT_PHASES * grna_factor));
	// cut_rates = local_cut_rate;
	// Now fill in the rest of the vector.
	for (i in seqLen(NUM_GRNAS - 1)) {
		local_cas_factor = cas_factor * (1 + GRNA_ACTIVITY_VARIATION - (i + 1) * GRNA_ACTIVITY_STEP);
		local_cut_rate = 1 - (1 - resistance_rate)^(mother_drive_count_c * local_cas_factor / (NUM_CUT_PHASES * grna_factor));
		// Concatenate the previous vector with the next cut rate calculated:
		// cut_rates = c(cut_rates, local_cut_rate);
	}
	
	// Then pass the rates as an argument to the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut(child_chromosome_1, local_cut_rate);
	casCut(child_chromosome_2, local_cut_rate);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)male_deposition(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ parent, f$ resistance_rate) {
	maternal_c = asInteger(parent.tag / 1000);
	maternal = asInteger((parent.tag - 1000 * maternal_c) / 100);
	paternal_c = asInteger((parent.tag - maternal_c  * 1000 - maternal * 100) / 10);
	paternal = parent.tag - maternal_c  * 1000 - maternal * 100 - paternal_c * 10;
	
	// If father doesn't have drive allele, no paternal deposition happens.
	if (maternal != 2 & paternal != 2)
		return;
	
	// Established: father had drive (both c and g) and child is female.
	if ((child_chromosome_1.countOfMutationsOfType(m2) & child_chromosome_1.countOfMutationsOfType(m8)) |
		(child_chromosome_2.countOfMutationsOfType(m2) & child_chromosome_2.countOfMutationsOfType(m8))) {
		if (child_chromosome_1.countOfMutationsOfType(m1) | child_chromosome_2.countOfMutationsOfType(m1)) {
			// Child is D/+
			if (runif(1) < resistance_rate) {
				// Convert the child to D/R2.
				child_chromosome_1.addNewDrawnMutation(m4, 2*NUM_GRNAS+1);
				child_chromosome_2.addNewDrawnMutation(m2, 2*NUM_GRNAS+1);
			}
		}
	}
}

//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut(o<Genome>$ chromosome, f cut_rates) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Vector of possible loci for cas9 to cut:
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci)) {
			// Check to see if cas9 cuts...
			if (runif(1) < cut_rates[j]) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addResistanceAllele(chromosome, cut_loci[0]);
			else {
				// If mutlple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2) and
				// everthing else through the rightmost site to m6 (cut).
				number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
				for (index in seqLen(number_of_cuts))
					chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites
			// to use during the next iteration of the for loop:
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}

//// FUNCTION FOR SIMULATING HOMOLOGY DIRECTED REPAIR.
function (void)hdr(o<Genome>$ chromosome, o<Individual>$ parent, f$ cut_rate, [l maleParent=F]) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
		
		// If chromosome has no wild type targets to cut, cas9 does nothing.
	if ( (chromosome.countOfMutationsOfType(m8) == 0) & (chromosome.countOfMutationsOfType(m2) == 0) )
		return;
	
	if (!maleParent) {
		// Determine presence of drive in this parent.
		parent_c1_drive_g = (parent.genome1.countOfMutationsOfType(m2) == NUM_GRNAS);
		parent_c1_drive_c = (parent.genome1.countOfMutationsOfType(m8) == NUM_GRNAS);
		parent_c2_drive_g = (parent.genome2.countOfMutationsOfType(m2) == NUM_GRNAS);
		parent_c2_drive_c = (parent.genome2.countOfMutationsOfType(m8) == NUM_GRNAS);
		
		parent_g_drive = parent_c1_drive_g | parent_c2_drive_g;
		parent_c_drive = parent_c1_drive_c | parent_c2_drive_c;
		
		parent_has_drive = parent_g_drive & parent_c_drive;
		
		// If parent doesn't have drive allele, nothing happens.
		if (!parent_has_drive)
			return;
	}
	if (maleParent) {
		maternal_c = asInteger(parent.tag / 1000);
		maternal = asInteger((parent.tag - 1000 * maternal_c) / 100);
		paternal_c = asInteger((parent.tag - maternal_c  * 1000 - maternal * 100) / 10);
		paternal = parent.tag - maternal_c  * 1000 - maternal * 100 - paternal_c * 10;
		
		// cat(maternal_c + "," + maternal + "," + paternal_c + "," + paternal + "\n");
		
		if ((maternal != 2 | maternal_c != 8) & (paternal != 2 | paternal_c != 8))
			return;
		
		// cat(maternal_c + "," + maternal + "," + paternal_c + "," + paternal + "\n");
	}
	
	// Rate of cutting occurs at the HOMING_PHASE_CUT_RATE, modified by gRNA saturation, if toggled on.
	//cut_rate = HOMING_PHASE_CUT_RATE;
	if (GRNA_SATURATION_SIMULATED)
		cut_rate = 1 - (1 - HOMING_PHASE_CUT_RATE)^(1/NUM_GRNAS);
	
	// Vector of possible loci.
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// At each possible locus...
	for (i in seqAlong(wt_loci)) 
		// Check to see if cas9 cuts...
		if (runif(1) < cut_rate)
			// Convert the locus temporarily to an m3,
			// representing that this site is being cut.
			chromosome.addNewDrawnMutation(m5, wt_loci[i]);
	
	// If any cuts were made...
	if (chromosome.countOfMutationsOfType(m5)) {
		// Determine how extreme the cuts are relative to the target package (the drive).
		cut_loci = chromosome.positionsOfMutationsOfType(m5);
		leftmost_cut_index = cut_loci[0];
		rightmost_cut_index = cut_loci[size(cut_loci) - 1];
		
		// Sections that have already been cut out of the chromosome
		// also contribute to the size of the cut section.
		missing_loci = chromosome.positionsOfMutationsOfType(m6);
		//print("leftmost_cut_index"+leftmost_cut_index);
		//print("sum(missing_loci < leftmost_cut_index);"+sum(missing_loci < leftmost_cut_index));
		//print("rightmost_cut_index"+rightmost_cut_index);
		
		// Adjusted indecies are amounts by which the cut ends differ
		// from the perfect cut that spans the entire target area.
		//ends =  c(NUM_GRNAS+1,NUM_GRNAS+2 ,2*NUM_GRNAS+2+1);
		
		// adjusted: -1
		adjusted_left_index = NUM_GRNAS+3-leftmost_cut_index - sum(missing_loci < leftmost_cut_index) - 1;

		rightmost_cut_index = rightmost_cut_index + sum(missing_loci > rightmost_cut_index);
		adjusted_right_index = (2*NUM_GRNAS+3) - 1 - rightmost_cut_index - 1;
		
		
		//adjusted_right_index = NUM_GRNAS - 1 - rightmost_cut_index;
      /*		
		print("leftmost_cut_index"+leftmost_cut_index);
		print("adjusted_left_index"+adjusted_left_index);
		print("rightmost_cut_index"+rightmost_cut_index);
		print("adjusted_right_index"+adjusted_right_index);
		*/
		

		successful_homing_rate = BASELINE_HOMING_SUCCESS_RATE * (1 - HOMING_EDGE_EFFECT * adjusted_left_index) * (1 - HOMING_EDGE_EFFECT * adjusted_right_index);
		// print("successful_homing_rate"+successful_homing_rate);
		// Check to see if homing succeeds.
		
		if (runif(1) < successful_homing_rate)
			for (i in (NUM_GRNAS+2+1):(2*NUM_GRNAS+2)) 
				chromosome.addNewDrawnMutation(m2, i);

		else {
			// A small percentage of individuals have complete failures of the homing drive,
			// resulting in the entire section of the chromosome becoming a resistance allele.
			total_failure_avoidance_rate = 0.9 * (1 - 0.1 * adjusted_left_index) * (1 - 0.1 * adjusted_right_index);
			
			if (runif(1) < total_failure_avoidance_rate) {
				// Some catastrophic failures become all R1, at the following rate:
				total_r1_rate = 0.001 * (1 + adjusted_right_index - adjusted_left_index);
				// All-R1 catastrophic failures occur only in HAPLOSUFFICIENT or HAPLOSLETHAL drives.
				if (runif(1) < total_r1_rate & (HAPLOLETHAL_DRIVE | RECESSIVE_LETHAL_DRIVE))
					for (i in (NUM_GRNAS+2+1):(2*NUM_GRNAS+2)) 
						chromosome.addNewDrawnMutation(m3, i);
				else
					for (i in (NUM_GRNAS+2+1):(2*NUM_GRNAS+2)) 
						chromosome.addNewDrawnMutation(m4, i);
			}
			// If neither homing nor a catastrophic failure occur, normal repair happens.
			else {
				// If just one cut was made, create an R1 or R2 resistance allele.
				if (chromosome.countOfMutationsOfType(m5) == 1)
					addResistanceAllele(chromosome, cut_loci[0]);
				else {
				//
					// If mutlple cuts were made, leftmost site to  (R2),
					// everthing else through the rightmost site to m4 (cut).
					number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
					for (index in seqLen(number_of_cuts)) 
						chromosome.addNewDrawnMutation(m5, cut_loci[0] + index + 1);
					chromosome.addNewDrawnMutation(m4, cut_loci[0]);
				}
			}
		}
	}
}

//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	// gRNA-chr
	m1_loci = source.positionsOfMutationsOfType(m1);
	m2_loci = source.positionsOfMutationsOfType(m2);
	m3_loci = source.positionsOfMutationsOfType(m3);
	m4_loci = source.positionsOfMutationsOfType(m4);
	m5_loci = source.positionsOfMutationsOfType(m5);
	m6_loci = source.positionsOfMutationsOfType(m6);
	
	// Cas-chr
	m7_loci = source.positionsOfMutationsOfType(m7);
	m8_loci = source.positionsOfMutationsOfType(m8);
	
	for (i in seqAlong(m1_loci))
		destination.addNewDrawnMutation(m1, m1_loci[i]);
	for (i in seqAlong(m2_loci))
		destination.addNewDrawnMutation(m2, m2_loci[i]);
	for (i in seqAlong(m3_loci))
		destination.addNewDrawnMutation(m3, m3_loci[i]);
	for (i in seqAlong(m4_loci))
		destination.addNewDrawnMutation(m4, m4_loci[i]);
	for (i in seqAlong(m5_loci))
		destination.addNewDrawnMutation(m5, m5_loci[i]);
	for (i in seqAlong(m6_loci))
		destination.addNewDrawnMutation(m6, m6_loci[i]);
	for (i in seqAlong(m7_loci))
		destination.addNewDrawnMutation(m7, m7_loci[i]);
	for (i in seqAlong(m8_loci))
		destination.addNewDrawnMutation(m8, m8_loci[i]);
}

//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
	// Set the childs chromosome 2 to the chromosome actually inherited from the father.
	maternal_c = asInteger(parent1.tag / 1000);
	maternal = asInteger((parent1.tag - 1000 * maternal_c) / 100);
	paternal_c = asInteger((parent1.tag - maternal_c  * 1000 - maternal * 100) / 10);
	paternal = parent1.tag - maternal_c  * 1000 - maternal * 100 - paternal_c * 10;
	if (runif(1) < 0.5) {
		// Child inherits father's maternal chromosome.
		if (maternal == 1)
			child.genome2.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
		if (maternal == 2)
			child.genome2.addNewDrawnMutation(m2, 2*NUM_GRNAS+1);
		if (maternal == 3)
			child.genome2.addNewDrawnMutation(m3, 2*NUM_GRNAS+1);
		if (maternal == 4)
			child.genome2.addNewDrawnMutation(m4, 2*NUM_GRNAS+1);
	}
	else {
		// Child inherits father's paternal chromosome.
		if (paternal == 1)
			child.genome2.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
		if (paternal == 2)
			child.genome2.addNewDrawnMutation(m2, 2*NUM_GRNAS+1);
		if (paternal == 3)
			child.genome2.addNewDrawnMutation(m3, 2*NUM_GRNAS+1);
		if (paternal == 4)
			child.genome2.addNewDrawnMutation(m4, 2*NUM_GRNAS+1);
	}
	
	// Allow recombination to happen
	// Another independent random choice
	if (runif(1) < 0.5) {
		// Child inherits father's maternal chromosome.
		if (maternal_c == 7)
			child.genome2.addNewDrawnMutation(m7, NUM_GRNAS);
		if (maternal_c == 8)
			child.genome2.addNewDrawnMutation(m8, NUM_GRNAS);
	}
	else {
		// Child inherits father's paternal chromosome.
		if (paternal_c == 7)
			child.genome2.addNewDrawnMutation(m7, NUM_GRNAS);
		if (paternal_c == 8)
			child.genome2.addNewDrawnMutation(m8, NUM_GRNAS);
	}
	
	// If the drive is sex linked, force daughters to inherit father's x and sons to inherit father's y:
	/*if (X_LINKED | Y_LINKED) {
        if(child.sex == "M")
            copy_genome(parent2Genome2, child.genome2);
        if(child.sex == "F")
            copy_genome(parent2Genome1, child.genome2);
    }*/
	if (HOMING_DRIVE) {
		// Apply effects that happen in the germline.
		// First, resistance alleles form.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_CUT_RATE_F);
		germline(child.genome2, parent1, GERMLINE_RESISTANCE_CUT_RATE_M, maleParent=T);
		// Next, homology directed repair allows for homing to occur.
		if (!MALE_ONLY_PROMOTER)
			hdr(child.genome1, parent1, HOMING_PHASE_CUT_RATE_F);
		hdr(child.genome2, parent1, HOMING_PHASE_CUT_RATE_M, maleParent=T);
		// Then additional resistance alleles form.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, LATE_GERMLINE_RESISTANCE_CUT_RATE_F);
		germline(child.genome2, parent1, LATE_GERMLINE_RESISTANCE_CUT_RATE_M, maleParent=T);
		
		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(child.genome1, child.genome2, parent1, EMBRYO_RESISTANCE_CUT_RATE_F);
		// if (child.sex == F)
			// male_deposition(child.genome1, child.genome2, parent1, EMBRYO_RESISTANCE_CUT_RATE_M);
	} // End homing block
	
	if (!HOMING_DRIVE & !Y_LINKED) {
		// Apply effects that happen in the germline.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_CUT_RATE_F);
		germline(child.genome2, parent2, GERMLINE_RESISTANCE_CUT_RATE_M);
		
		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(child.genome1, child.genome2, parent1, EMBRYO_RESISTANCE_CUT_RATE_F);
		// if (child.sex == F)
			// male_deposition(child.genome1, child.genome2, parent2, EMBRYO_RESISTANCE_CUT_RATE_M);
	} //end not homing/tads modification block
	
	// If the drive is x-linked, prevent gene drive mechanics on Y chromosome by resetting it:
	/*if (X_LINKED)
        if(child.sex == "M")
            copy_genome(parent2Genome2, child.genome2);*/
	
	// Offspring may be non viable offspring if drive
	// is haplolethal or recesive lethal.
	// Booleans describing presence of R2 allele:
	res_2_c_1 = child.genome1.countOfMutationsOfType(m4) > 0;
	res_2_c_2 = child.genome2.countOfMutationsOfType(m4) > 0;
	/*
    	// If drive is haplolethal:
    	// Offspring not viable if r2 on either chromosome.
    	if (HAPLOLETHAL_DRIVE & (res_2_c_1 | res_2_c_2))
    		 sim.killIndividuals(child);
   	    // child.fitnessScaling = 0.0;
   	 // If drive is recessive lethal:
   	 // Offspring not viable if r2 on both chromosomes.
    	if (RECESSIVE_LETHAL_DRIVE & res_2_c_1 & res_2_c_2)
  	       sim.killIndividuals(child);
   	    // child.fitnessScaling = 0.0;
    */
	child.tag = 0;
	child.tagF = 1.0;
	return T;
}

//// LETHAL EFFECT FOR HAPLOLETHAL_DRIVE AND RECESSIVE_LETHAL_DRIVE
10: early() {
	// Offspring may be non viable offspring if drive
	// is haplolethal or recesive lethal.
	// Booleans describing presence of R2 allele:
	all = p2.individuals;
	for (ind in all) {
		res_2_c_1 = ind.genome1.countOfMutationsOfType(m4) > 0;
		res_2_c_2 = ind.genome2.countOfMutationsOfType(m4) > 0;
		// If drive is haplolethal:
		// Offspring not viable if r2 on either chromosome.
		if (HAPLOLETHAL_DRIVE & (res_2_c_1 | res_2_c_2))
			sim.killIndividuals(ind);
		// If drive is recessive lethal:
		// Offspring not viable if r2 on both chromosomes.
		if (RECESSIVE_LETHAL_DRIVE & res_2_c_1 & res_2_c_2)
			sim.killIndividuals(ind);
	}

}

//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	// Representation of the value of the two chromosomes.
	fitness_value = 1.0;
	
	// Check both chromosomes for drive and type 2 resistance allele.
	// These are the only variants that affect fitness.
	drive_c_on_1 = ind.genome1.countOfMutationsOfType(m8) == NUM_GRNAS;
	drive_c_on_2 = ind.genome2.countOfMutationsOfType(m8) == NUM_GRNAS;
	drive_g_on_1 = ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS;
	drive_g_on_2 = ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS;
	res2_on_1 = ind.genome1.countOfMutationsOfType(m4) > 0;
	res2_on_2 = ind.genome2.countOfMutationsOfType(m4) > 0;
	wt_c_1 = ind.genome1.countOfMutationsOfType(m7) > 0;
	wt_c_2 = ind.genome2.countOfMutationsOfType(m7) > 0;
	wt_g_1 = ind.genome1.countOfMutationsOfType(m1) > 0;
	wt_g_2 = ind.genome2.countOfMutationsOfType(m1) > 0;
	
	somatic_fitness_mult = 1;
	if (RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE|HAPLOLETHAL_SUPPRESSION_DRIVE){
		if (ind.sex == "F")
			somatic_fitness_mult = SOMATIC_FITNESS_MUTLIPLIER_F;
	}
	// Check both chromosomes for the drive.
	/*if (drive_c_on_1 & drive_c_on_2) {
		if (drive_g_on_1 & drive_g_on_2){
			fitness_value = 	DD_FITNESS_VALUE_CAS * DD_FITNESS_VALUE;
		}
		if (drive_g_on_1){
			fitness_value = 	DD_FITNESS_VALUE_CAS * DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value = 	fitness_value  * somatic_fitness_mult;
			}
		}
		if (drive_g_on_2){
			fitness_value = 	DD_FITNESS_VALUE_CAS * DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value = 	fitness_value  * somatic_fitness_mult;
			}
		}
	}
	
	if (drive_c_on_1 | drive_c_on_2) {
		if (drive_g_on_1 & drive_g_on_2){
			fitness_value = 	DX_FITNESS_VALUE_CAS * DD_FITNESS_VALUE;
		}
		if (drive_g_on_1){
			fitness_value = 	DX_FITNESS_VALUE_CAS * DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value =	fitness_value  * somatic_fitness_mult;
			}
		}
		if (drive_g_on_2){
			fitness_value = 	DX_FITNESS_VALUE_CAS * DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value = 	fitness_value  * somatic_fitness_mult;
			}
		}
	}
	if (!drive_c_on_1 & !drive_c_on_2) {
		if (drive_g_on_1 & drive_g_on_2){
			fitness_value = 	DD_FITNESS_VALUE;
		}
		if (drive_g_on_1){
			fitness_value = 	DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value = 	fitness_value;
			}
		}
		if (drive_g_on_2){
			fitness_value = 	DD_FITNESS_VALUE_CAS * DX_FITNESS_VALUE;
			if (wt_g_1|wt_g_2){
				fitness_value = 	fitness_value;
			}
		}
	}*/
	
	if (drive_g_on_1 & drive_g_on_2) {
		fitness_value = fitness_value * DD_FITNESS_VALUE;
	} else if (drive_g_on_1 | drive_g_on_2) {
		fitness_value = fitness_value * DX_FITNESS_VALUE;
	}
	
	if (drive_c_on_1 & drive_c_on_2) {
		fitness_value = fitness_value * DD_FITNESS_VALUE_CAS;
	} else if (drive_c_on_1 | drive_c_on_2) {
		fitness_value = fitness_value * DX_FITNESS_VALUE_CAS;
	}
	
	if (FEMALE_RIDL) {
        if (ind.sex == "F" & (drive_g_on_1 | drive_g_on_2))
				fitness_value = 0.0;
	 }
	 
	 if (BOTH_SEX_RIDL) {
        if (drive_g_on_1 | drive_g_on_2)
            fitness_value = 0.0;
    }
    return fitness_value;
}

//// FUNCTION FOR EVALUATING INFERTILITY CAUSED BY SUPRESSION DRIVES.
function (logical)isInfertile(o<Individual>$ ind) {
	dr_count = sum(ind.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	r2_count = sum(ind.genomes.countOfMutationsOfType(m4) > 0);
	
	if (ind.sex == "F") {
		if(DOMINANT_STERILE_R2)
			if(r2_count >= 1)
				return T;
		if(DOMINANT_FEMALE_STERILE)
			if(dr_count >= 1)
				return T;
		if (RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE)
			if (dr_count + r2_count == 2)
				return T;
		if (HAPLOLETHAL_SUPPRESSION_DRIVE)
			if (dr_count == 2)
				return T;
	}
	
	if (ind.sex == "M"){
		if(MALE_SIT){
			if(dr_count + r2_count == 2)
				return T;
		}
	}
	
	return F;
}

function (integer)setTag(o<Individual>$ ind) {
	new_tag = 0;
	if (ind.genome1.countOfMutationsOfType(m1))
		new_tag = new_tag + 100;
	if (ind.genome1.countOfMutationsOfType(m2))
		new_tag = new_tag + 200;
	if (ind.genome1.countOfMutationsOfType(m3))
		new_tag = new_tag + 300;
	if (ind.genome1.countOfMutationsOfType(m4))
		new_tag = new_tag + 400;
	if (ind.genome1.countOfMutationsOfType(m7))
		new_tag = new_tag + 7000;
	if (ind.genome1.countOfMutationsOfType(m8))
		new_tag = new_tag + 8000;
	if (ind.genome2.countOfMutationsOfType(m1))
		new_tag = new_tag + 1;
	if (ind.genome2.countOfMutationsOfType(m2))
		new_tag = new_tag + 2;
	if (ind.genome2.countOfMutationsOfType(m3))
		new_tag = new_tag + 3;
	if (ind.genome2.countOfMutationsOfType(m4))
		new_tag = new_tag + 4;
	if (ind.genome2.countOfMutationsOfType(m7))
		new_tag = new_tag + 70;
	if (ind.genome2.countOfMutationsOfType(m8))
		new_tag = new_tag + 80;
	
	// cat(new_tag+"|");
	return new_tag;
}

// RELEASE OF TRANSGENES
10: reproduction(p0){
    // Maintain the population
    if (asInteger(DROP_SIZE) > 0) {
        for (repeat in 1:asInteger(DROP_SIZE)) {
            new_ind = p1.addCloned(individual);
            new_ind.age = 1; // age to 2 next week
        }
    }
    // cat("okay"+"\n");
}

11: first() {
    drop = p1.individuals;
    p2.takeMigrants(drop);
}

//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(p2, "F") {
	// First, evaluate whether reproduction is suppressed by a population suppression drive,
	// Then, select a mate based on fitness, then generate offspring.
	if (individual.age < 2)
		return;
	
	// Check to see if this female is infertile because of drive mechanics:
	if (isInfertile(individual))
		return;
	
	if (individual.tag == 0 | runif(1) < REMATE_CHANCE) {
		// Females choose a random provisional mate, but make a final mating decision based on the
		// attractiveness of that mate, as determined by the fitness of the mate. If a mate is
		// rejected, the female tries again, up to a maximum number of tries, after which she gives up.
		attempt_no = 0;
		found_mate = F;
		while (1) {
			// First, select a random potential mate.
			selected_mate = subpop.sampleIndividuals(1, sex="M", minAge=2);
			if (!selected_mate.size())
				return;  // No available mates.
			
			// Determine attractiveness of potential mate.
			mate_attractiveness = genotypeFitness(selected_mate);
			
			// Determine if this mate is chosen, based on attractiveness.
			if (runif(1) < mate_attractiveness) {
				found_mate = T;
				break;  // Select this mate.
			}
			// After ten candidates fail, female gives up.
			attempt_no = attempt_no + 1;
			if (attempt_no == MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE)
				return;
		}
		if (found_mate) {
			// Mate has now been selected.
			// Check to see if mate is infertile because of drive mechanics.
			if (isInfertile(selected_mate)) {
				individual.tagF = 100.0;
				individual.tag = setTag(selected_mate);
				return;
			}
			// Check to see if male somatic fitness penalty will decrease number of offspring. Fecundity effected only in offspring of D/+ males.
			// tagF holds the somatic fitness multiplier of the mate.
			if (selected_mate.countOfMutationsOfType(m1) & selected_mate.countOfMutationsOfType(m2))
				individual.tagF = SOMATIC_FITNESS_MUTLIPLIER_M;
			// The tag stores info about the mate's genotype.
			individual.tag = setTag(selected_mate);
		}
	}
	
	// Mate has now been selected.
	// Check to see if mate was infertile because of drive mechanics.
	if (individual.tagF == 100.0)
		return;
		
	if (individual.tag != 0) {
		// Individual has mated, and may lay eggs.
		// Females don't always lay eggs:
		if (runif(1) > FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK)
			return;
		
		selected_mate = sample(p3.individuals, 1);
		// Actual mate genome.
		maternal_c = asInteger(individual.tag / 1000);
		maternal = asInteger((individual.tag - 1000 * maternal_c) / 100);
		paternal_c = asInteger((individual.tag - maternal_c  * 1000 - maternal * 100) / 10);
		paternal = individual.tag - maternal_c  * 1000 - maternal * 100 - paternal_c * 10;
		
		// Fecundity is based on both the crowding/competition in the system, as well as female fitness.
		// Number of offspring number based on binomial distrobution.
		num_offspring = rpois(1, BETAMAX * 2);
		num_offspring = num_offspring * genotypeFitness(individual) * individual.tagF;
		if (GL_RUN)
			num_offspring = num_offspring / BONUS_POP_FACTOR;
		
		num_offspring = asInteger(round(num_offspring));
		sex_ratio = 1 - (0.5 * (1 - X_SHRED_RATE)) / (0.5 + (0.5 * (1 - X_SHRED_RATE)));
		for (i in seqLen(num_offspring)) {
			// Add offspring to the subpopulation.
			if (maternal == 2 | paternal == 2)
				// Add individuals with a biased sex ratio.
				subpop.addCrossed(individual, selected_mate, sex_ratio);
			else
				offspring = subpop.addCrossed(individual, selected_mate);
		}
	}
}

//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 early() {
	// Start with a population of wild type flies.
	sim.addSubpop("p2", asInteger(CAPACITY));
	
	// for (i in seqLen(NUM_GRNAS))
	p2.individuals.genomes.addNewDrawnMutation(m7, NUM_GRNAS);
	p2.individuals.genomes.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
	
	all = p2.individuals;
	female_ages = size(INITIAL_FEMALE_AGE_DISTRIBUTION) - 1;
	male_ages = size(INITIAL_MALE_AGE_DISTRIBUTION) - 1;
	for (ind in all) {
		if (ind.sex == "F") {
			ind.age = sample(0:female_ages, 1, F, INITIAL_FEMALE_AGE_DISTRIBUTION);
		}
		else {
			ind.age = sample(0:male_ages, 1, F, INITIAL_MALE_AGE_DISTRIBUTION);
		}
	}
	all.tag = 0;
	all.tagF = 1.0;
	sim.addSubpop("p3", 1, 1.0); // formal parameter
	p3.individuals.age = 5200;
}

//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
10 early() {
	 // Add one modified individuals to p0.
    if (MALE_ONLY_DROP)
        // Drop a population of only males.
        sim.addSubpop("p0", 1, 1.0);
    else if (FEMALE_ONLY_DROP)
        // Drop a population of only females.
        sim.addSubpop("p0", 1, 0.0);
    else
        // Do not use this
        sim.addSubpop("p0", 1);

    drop = p0.individuals;
    drop.age = 2;
    drop.tag = 0;
    drop.tagF = 1.0;
	
	// Now set the drop individuals to the correct genotypes:
	drop.genomes.addNewDrawnMutation(m8, NUM_GRNAS);
	drop.genomes.addNewDrawnMutation(m2, 2*NUM_GRNAS+1);
	
	// For heterozygous drop, one of the chromosomes is set to wild type:
	if (HETEROZYGOUS_DROP)
		// Only change gRNA-chr to wild type
		drop.genome2.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
	
	// In X_LINKED males' genome2 (from father) is always wt.
	if (X_LINKED) {
		males = (drop.sex == "M");
		// Set all Y chromosomes to wt.
		drop[males].genome2.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
		drop[males].genome2.addNewDrawnMutation(m7, NUM_GRNAS);
	}
	
	// In Y_LINKED drive, males' genome2 (from father) is always dr and genome1 is wt.
	if (Y_LINKED) {
		drop.genomes.addNewDrawnMutation(m1, 2*NUM_GRNAS+1);
		drop.genomes.addNewDrawnMutation(m7, NUM_GRNAS);
		males = (drop.sex == "M");
		// Set all Y chromosomes to dr.
		drop[males].genome2.addNewDrawnMutation(m2, 2*NUM_GRNAS+1);
		drop[males].genome2.addNewDrawnMutation(m8, NUM_GRNAS);
	}
	
	 // Initialize the subpop of release
    sim.addSubpop("p1", 0);
}

10: reproduction(p1, "M"){
	release = p2.addCloned(p1.individuals[0]);
	release.age = 2;
}


//// AGE BASED SURVIVAL RULES.
early() {
	all = p2.individuals;
	new_larvae = sum(all.age == 0);
	old_larvae = sum(all.age == 1);
	f_larvae = sum(all[all.sex == "F"].age==0);
	
	//rm("ACTUAL_LARVAE", removeConstants=T);
	//defineConstant("ACTUAL_LARVAE", f_larvae);
	
	for (ind in all) {
		drive_g_on_1 = ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS;
		drive_g_on_2 = ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS;
		
		competition_ratio = (new_larvae + old_larvae * OLD_LARVA_COMPETITION_FACTOR) / (NUM_ADULT_FEMALES * (2 * BETAMAX * FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK + 2 * 0.285714 * OLD_LARVA_COMPETITION_FACTOR));
		
		//cat(INITIAL_FEMALE_AGE_DISTRIBUTION[1]);
		//cat(competition_ratio);    
		
		if (DENSITY_GROWTH_CURVE == "concave")
			viability = LOW_DENSITY_GROWTH_RATE * (2 * INITIAL_FEMALE_AGE_DISTRIBUTION[1]) / (BETAMAX) / (((LOW_DENSITY_GROWTH_RATE - 1) * competition_ratio) + 1);
		if (DENSITY_GROWTH_CURVE == "linear")
			viability = (2 * INITIAL_FEMALE_AGE_DISTRIBUTION[1]) / (BETAMAX) * ((1 - LOW_DENSITY_GROWTH_RATE)*competition_ratio + LOW_DENSITY_GROWTH_RATE);
		if (DENSITY_GROWTH_CURVE == "convex")
			viability = (2 * INITIAL_FEMALE_AGE_DISTRIBUTION[1]) / (BETAMAX) * ( (1 - LOW_DENSITY_GROWTH_RATE) * (competition_ratio + 1) * (competition_ratio - 1) + 1 );
		
		// viability = (INITIAL_FEMALE_AGE_DISTRIBUTION[1]) *2  / (BETAMAX) * (LOW_DENSITY_GROWTH_RATE/((LOW_DENSITY_GROWTH_RATE-1)*competition_ratio-LOW_DENSITY_GROWTH_RATE)+LOW_DENSITY_GROWTH_RATE+1);
		
		if (ind.age == 0)
			ind.fitnessScaling = ifelse(viability<0,0.0,viability);
		else if (ind.age == 1){
			ind.fitnessScaling = 1.0;
			if (FEMALE_RIDL) {
				if (ind.sex == "F" & (drive_g_on_1 | drive_g_on_2)) {
					ind.fitnessScaling = 0.0;
				}	
			}
		}
		else {
			if (ind.sex == "M")
				ind.fitnessScaling = (4 - ind.age) / (5 - ind.age);
			else
				ind.fitnessScaling = (7 - ind.age) / (8 - ind.age);
		}
	}
	cat(INITIAL_FEMALE_AGE_DISTRIBUTION[1] + ' ');
	cat(competition_ratio + ' ');
	cat(viability + ' \n');
}

//// FOR SPECIAL RUNS TO CALC GENETIC LOAD.
/*late() {
    if (GL_RUN) {
        all = p2.individuals;
        total_males = 0;
        fertile_males = 0;
        total_females = 0;
        fertile_females = 0;
        for (ind in all) {
            if (ind.sex == "M") {
                if (!isInfertile(ind))
                    fertile_males = fertile_males + 1;
                total_males = total_males + 1;
            }
            else {
                if (!isInfertile(ind))
                    fertile_females = fertile_females + 1;
                total_females = total_females + 1;
            }
        }
        if (total_males == 0 | total_females == 0)
            new_bonus_pop_factor = 1;
        else {
            if (X_SHRED_RATE == 0)
                new_bonus_pop_factor = (fertile_males / total_males) * (fertile_females / total_females);
            else
                // Need a different bonus pop factor for drives that bias the sex ratio.
                new_bonus_pop_factor = (fertile_males / total_males) * (fertile_females / total_females) * (total_females / (total_females + total_males)) / 0.5;
        }
        rm("PREV_BONUS_POP_FACTOR", removeConstants=T);
        defineConstant("PREV_BONUS_POP_FACTOR", BONUS_POP_FACTOR);
        rm("BONUS_POP_FACTOR", removeConstants=T);
        defineConstant("BONUS_POP_FACTOR", new_bonus_pop_factor);
    }
}
*/
//// PROGRAM OUTPUT.
late() {
	// Calculate rates that we are intersted in:
	num_wt = 0;
	num_dr = 0;
	num_complete_r1 = 0;
	num_partial_r1 = 0;
	num_complete_r2 = 0;
	num_partial_r2 = 0;
	all = p2.individuals;
	
	num_wt = sum(all.genomes.countOfMutationsOfType(m1) == NUM_GRNAS);
	num_dr = sum(all.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	num_cas = sum(all.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
	num_complete_r1 = sum(all.genomes.countOfMutationsOfType(m3) == NUM_GRNAS);
	num_partial_r1 = sum(all.genomes.countOfMutationsOfType(m3) > 0
		& all.genomes.countOfMutationsOfType(m1) > 0
		& all.genomes.countOfMutationsOfType(m4) == 0);
	num_complete_r2 = sum(all.genomes.countOfMutationsOfType(m4) > 0
		& all.genomes.countOfMutationsOfType(m1) == 0);
	num_partial_r2 = sum(all.genomes.countOfMutationsOfType(m4) > 0
		& all.genomes.countOfMutationsOfType(m1) > 0);
	num_has_drive = sum(all.genome1.countOfMutationsOfType(m2) == NUM_GRNAS
		| all.genome2.countOfMutationsOfType(m2) == NUM_GRNAS);
	num_has_cas   = sum(all.genome1.countOfMutationsOfType(m8) == NUM_GRNAS
		| all.genome2.countOfMutationsOfType(m8) == NUM_GRNAS);
	
	rate_wt  = num_wt / (2 * size(all));
	rate_dr  = num_dr / (2 * size(all));
	rate_cas = num_cas / (2 * size(all));
	rate_complete_r1 = num_complete_r1 / (2 * size(all));
	rate_partial_r1 = num_partial_r1 / (2 * size(all));
	rate_complete_r2 = num_complete_r2 / (2 * size(all));
	rate_partial_r2 = num_partial_r2 / (2 * size(all));
	rate_has_drive = num_has_drive / (size(all));
	rate_has_cas   = num_has_cas   / (size(all));
	f = all[all.sex == "F"];
	m = all[all.sex == "M"];
	adult_f = f[f.age > 0];
	/*    // Output for humans to look at:
    cat("Rates in " + p2.individualCount + " individuals in generation " + paste(asInteger(sim.cycle) - 1) + ":\n");
    cat("wt: " + rate_wt + "\tdr: " + rate_dr + "\tr1: " + rate_complete_r1 + "\tpart r1: " + rate_partial_r1 +
            "\tr2: " + rate_complete_r2 + "\tpart r2: " + rate_partial_r2 + "\t%inds with dr: " + rate_has_drive + "\n");
    if (num_dr)
        cat("Number of drive alleles present: " + num_dr + "\n");*/
	
	total_adults = sum(all.age > 0); // 1 grows to 2 in the next cycle
	total_adult_females = sum(f.age > 0);
	num_fertile_female = sum(adult_f.countOfMutationsOfType(m1) == 2);
	catn("OUT:" + sim.cycle + "," + total_adults + "," + total_adult_females + "," + num_fertile_female + "," + rate_dr + "," + rate_has_drive + "," + rate_cas + "," + rate_has_cas + "," + DRIVE_CONVERSION_RATE + "," + TOTAL_GERMLINE_RESISTANCE_RATE + "," +  DROP_RATIO + "," + EMBRYO_RESISTANCE_CUT_RATE_M + "," + LOW_DENSITY_GROWTH_RATE + "," + DENSITY_GROWTH_CURVE + ",");
	
	if(total_adult_females == 0| p2.individualCount == 0){
		larva_f = f[f.age==0];
		if(sum(larva_f.countOfMutationsOfType(m1) == 2) == 0)
			sim.simulationFinished();
		//catn("OUT:: " + "1,1,1,1,1");			
	}
	
	// Calculate expected number of individuals in the next generation (for calcing genetic load in python)
	// expected_next_gen_pop_if_no_drive = 2 * sum(all.sex == "F") * (LOW_DENSITY_GROWTH_RATE / (((LOW_DENSITY_GROWTH_RATE - 1) * p1.individualCount / CAPACITY) + 1));
	//expected_next_gen_pop_if_no_drive = sum(all.sex == "F") * (LOW_DENSITY_GROWTH_RATE / (((LOW_DENSITY_GROWTH_RATE - 1) * p2.individualCount / CAPACITY) + 1));
	//expected_larvae_if_no_drive = BETAMAX * sum(all[all.sex == "F"].age>0) * FRACTION_OF_FEMALES_THAT_REPRODUCE_PER_WEEK;
	
	// Output for python to look at:
	//catn("PYTHON:: " + rate_wt + " " + rate_dr + " " + rate_complete_r1 + " " + rate_partial_r1 + " " +
	//      rate_complete_r2 +" " + rate_partial_r2 + " " + rate_has_drive + " " +
	//    paste(asInteger(sim.cycle) - 1) + " " + ACTUAL_LARVAE * PREV_BONUS_POP_FACTOR + " " + expected_larvae_if_no_drive);
	
	// adult_female = sum(all[all.sex == "F"].age>0);
	// adult_male = sum(all[all.sex == "M"].age>0);
	// catn("SEX RATIO (F:M) = " + adult_female + ":" + adult_male + " = " + adult_female / adult_male + "\n");
	// m_adult = all[all.sex == "M" & all.age>0];
	// f_adult = all[all.sex == "F" & all.age>0];
	// m_larv = all[all.sex == "M" & all.age==0];
	// f_larv = all[all.sex == "F" & all.age==0];
	// ddm = sum(m_adult.countOfMutationsOfType(m2) == 2) / (size(m_adult));
	// dwm = sum(m_adult.countOfMutationsOfType(m2) == 1 & m_adult.countOfMutationsOfType(m1) == 1) / (size(m_adult));
	// drm = sum(m_adult.countOfMutationsOfType(m2) == 1 & m_adult.countOfMutationsOfType(m4) == 1) / (size(m_adult));
	// wwm = sum(m_adult.countOfMutationsOfType(m1) == 2) / (size(m_adult));
	// wrm = sum(m_adult.countOfMutationsOfType(m1) == 1 & m_adult.countOfMutationsOfType(m4) == 1) / (size(m_adult));
	// rrm = sum(m_adult.countOfMutationsOfType(m4) == 2) / (size(m_adult));
	// ddf = sum(f_adult.countOfMutationsOfType(m2) == 2) / (size(f_adult));
	// dwf = sum(f_adult.countOfMutationsOfType(m2) == 1 & f_adult.countOfMutationsOfType(m1) == 1) / (size(f_adult));
	// drf = sum(f_adult.countOfMutationsOfType(m2) == 1 & f_adult.countOfMutationsOfType(m4) == 1) / (size(f_adult));
	// wwf = sum(f_adult.countOfMutationsOfType(m1) == 2) / (size(f_adult));
	// wrf = sum(f_adult.countOfMutationsOfType(m1) == 1 & f_adult.countOfMutationsOfType(m4) == 1) / (size(f_adult));
	// rrf = sum(f_adult.countOfMutationsOfType(m4) == 2) / (size(f_adult));
	// ddml = sum(m_larv.countOfMutationsOfType(m2) == 2) / (size(m_larv));
	// dwml = sum(m_larv.countOfMutationsOfType(m2) == 1 & m_larv.countOfMutationsOfType(m1) == 1) / (size(m_larv));
	// drml = sum(m_larv.countOfMutationsOfType(m2) == 1 & m_larv.countOfMutationsOfType(m4) == 1) / (size(m_larv));
	// wwml = sum(m_larv.countOfMutationsOfType(m1) == 2) / (size(m_larv));
	// wrml = sum(m_larv.countOfMutationsOfType(m1) == 1 & m_larv.countOfMutationsOfType(m4) == 1) / (size(m_larv));
	// rrml = sum(m_larv.countOfMutationsOfType(m4) == 2) / (size(m_larv));
	// ddfl = sum(f_larv.countOfMutationsOfType(m2) == 2) / (size(f_larv));
	// dwfl = sum(f_larv.countOfMutationsOfType(m2) == 1 & f_larv.countOfMutationsOfType(m1) == 1) / (size(f_larv));
	// drfl = sum(f_larv.countOfMutationsOfType(m2) == 1 & f_larv.countOfMutationsOfType(m4) == 1) / (size(f_larv));
	// wwfl = sum(f_larv.countOfMutationsOfType(m1) == 2) / (size(f_larv));
	// wrfl = sum(f_larv.countOfMutationsOfType(m1) == 1 & f_larv.countOfMutationsOfType(m4) == 1) / (size(f_larv));
	// rrfl = sum(f_larv.countOfMutationsOfType(m4) == 2) / (size(f_larv));
	// catn("DATHEAD:: Male adults,Female adults,Male larvae,Female larvae,New larvae for genetic load purposes (before multiplying by bonus factor),Pop bonus factor,Next gen expected female larvae," +
	//                     "d/d males,d/+ males,d/r males,+/+ males,+/r males,r/r males,d/d females,d/+ females,d/r females,+/+ females,+/r females,r/r females," +
	//                     "d/d male larvae,d/+ male larvae,d/r male larvae,+/+ male larvae,+/r male larvae,r/r male larvae," +
	//                     "d/d female larvae,d/+ female larvae,d/r female larvae,+/+ female larvae,+/r female larvae,r/r female larvae,Genetic Load");
	// catn("DATA:: " + size(m_adult) + "," + size(f_adult) + "," + size(m_larv) + "," + size(f_larv) + "," + ACTUAL_LARVAE + "," + PREV_BONUS_POP_FACTOR + "," + expected_larvae_if_no_drive +
	//                                                                     "," + ddm + "," + dwm + "," + drm + "," + wwm + "," + wrm + "," + rrm +
	//                                                                     "," + ddf + "," + dwf + "," + drf + "," + wwf + "," + wrf + "," + rrf +
	//                                                                     "," + ddml + "," + dwml + "," + drml + "," + wwml + "," + wrml + "," + rrml +
	//                                                                     "," + ddfl + "," + dwfl + "," + drfl + "," + wwfl + "," + wrfl + "," + rrfl);
	// Raw CSV output option.
	//    r1 = num_partial_r1 + num_complete_r1;
	//    r2 = num_partial_r2 + num_complete_r2;
	//    catn(num_wt + "," + num_dr + "," + r1 + "," + r2 + "," + num_complete_r1 + "," + num_partial_r1 + "," + num_complete_r2 + "," + num_partial_r2 + "," + size(all));
	// End condition for investigating when drive surpases a threshold:
	//    if ((sim.generation > 12 & rate_dr == 0.0) | rate_dr > 0.1)
	//        sim.simulationFinished();
	// Condition for ending simulation when drive takes over or dies out:
	if (p2.individualCount == 0 | (rate_has_drive == 0 & sim.cycle > 41))
		sim.simulationFinished();
}

//// PROGRAM END CONDITION.
317 late() {
	sim.simulationFinished();
}
